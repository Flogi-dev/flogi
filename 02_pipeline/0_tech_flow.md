Flogi의 심장부, “테크 플로우”에 대한 Figma 디자인과 설명   
Flogi 내부에서 어떤 작업흐름을 통해해 커밋 메시지가 생성되는지에 대한 "핵심 엔진"의 설계도  
이 플로우는 Flogi의 기술적 깊이와 정교함을 보여주는 매우 중요한 부분

**Flogi 서비스 플로우 \- 내부 핵심 로직**

**Tier 0: 트리거 감지 (이벤트 발생)**

* 사용자 작업 종료, IDE 종료, 스케줄링 등 다양한 외부 또는 내부 트리거에 의해 Flogi 서비스 로직이 시작되는 지점

**Tier 1: 변경 범위 초기 식별 (Diff 기반 리스트업)**

* 트리거가 감지되면, 가장 먼저 해당 저장소(repository)에서 **Diff (변경 사항)가 있는 파일 목록**과 각 파일 내에서 **Diff가 있는 함수 목록**을 JSON 형식으로 추출하고 리스트업. 이 단계는 분석 대상을 구체화하는 첫걸음

**Tier 1.5: 함수별 연관 관계 분석 (컨텍스트 확장)**

* Tier 1에서 식별된 각 함수에 대해 개별적으로 심층 분석을 수행하여 컨텍스트를 확장  
  * **Main module**: 현재 분석 대상이 되는 핵심 함수를 의미  
  * **Sub module 1**: 이 Main module이 다른 파일에 정의된 다른 함수들의 return 값을 import하여 사용하는 경우, 그 외부 함수들을 모두 리스트업 (의존성 분석 \- 나가는 방향)  
  * **Sub module 2**: 다른 파일의 함수들이 이 Main module을 import하여 사용하는 경우, 그 외부 함수들을 모두 리스트업 (영향도 분석 \- 들어오는 방향)  
  * 이 "Sub module"들은 Main module의 변경이 어떤 영향을 주고받는지   
    이해하는 데 중요한 단서

**Tier 2: 1차 분석 대상 함수 선정 (개수 기반 필터링)**

* 한 파일 내에 변경된 함수의 개수에 따라 1차 분석 대상(스코핑 대상) 함수를 선정  
  * **파일 내 변경 함수 5개 이하**: 모든 변경 함수를 분석 대상으로 정함  
  * **파일 내 변경 함수 5개 초과**: Tier 1.5에서 분석된 "Sub module"의 개수가 많은 순서대로 상위 5개의 함수만 선택하여 스코핑을 진행 (핵심 변경 함수에 집중)


**Tier 3: 1차 스코핑 (AST 기반 유사도 측정 및 필터링 \- Sub module 대상)**

* Tier 2에서 선정된 각 Main module에 대해, Tier 1.5에서 리스트업된 Sub module들과의 유사도를 측정하여 관련성이 높은 Sub module을 필터링, 이 단계는 AST(Abstract Syntax Tree, 추상 구문 트리) 기반의 정적 분석 기법(예: Jaccard 유사도, Simhash)을 활용  
  * **Sub module 개수 20개 이하**:  
    * Main module과 모든 Sub module 간의 AST 기반 유사도를 측정  
    * 유사도 점수가 높은 순서대로 상위 7개(Pro & Team 플랜은 10개)의 Sub module을 선택  
  * **Sub module 개수 20개 초과**:  
    * 모든 Sub module과 유사도를 계산하는 대신, 먼저 무작위로 7개(Pro & Team 플랜은 10개)의 Sub module을 샘플링  
    * 이 샘플링된 Sub module들과 Main module 간의 AST 기반 유사도를 측정하여 상위 3개(Pro & Team 플랜은 5개)를 선택, 이 과정을 3번 반복하여 총 9개(Pro & Team 플랜은 15개)가 아닌, *각각 3개씩 선택하여 총 3개의 그룹을 만듦*  
      *즉 각 함수마다 7개*(Pro & Team 플랜은 10개) *총 (21or30) 에서*   
      "Top3(Pro \&Team \- 5\) \*3회 반복으로 Scoping 하여 총 3개(Pro\&Team \- 5)씩 그룹을 만드는 것

**Tier 4: 2차 스코핑 (임베딩 기반 유사도 확인 \- 플랜 및 리소스 상황별 분기)**

* 1차 스코핑된 Sub module들에 대해 임베딩을 활용하여 더욱 정교하게 관련성을 분석, 이 단계는 여러 전략(A, B, C)으로 나뉘어, 사용자의 플랜 및 시스템 리소스 상황에 따라 다른 방식을 사용  
  * **A-2차 Scoping (Pro & Org 플랜은 무조건 Bert 고정)**:  
    * Main module은 **BERT 임베딩**을 사용  
    * 1차 스코핑된 Top 7(또는 10\) Sub module 각각에 대해,  
      미리 구축된 **임베딩 캐시를 확인**  
  * **B-2차 Scoping (Fallback \- CPU/GPU 리소스 부족 시)**:  
    * Main module은 상대적으로 가벼운 **Code2Vec 임베딩**을 사용  
    * 1차 스코핑된 Top 7(또는 10\) Sub module 각각에 대해 임베딩 캐시를 확인  
  * **C-2차 Scoping (Tier 3에서 Sub module이 20개 초과였던 경우의 정제된 그룹 대상)**:  
    * Tier 3에서 최종적으로 선택된 Top 3(또는 5\) Sub module 그룹을 대상으로 함  
    * Main module은 **BERT 임베딩**을 사용  
    * 각 Sub module에 대해 임베딩 캐시를 확인

    

**Tier 5-a & 5-b: 임베딩 캐시 결과에 따른 분기**

* Tier 4에서 확인한 임베딩 캐시 존재 유무 및 추가 조건에 따라 다음 단계가 결정  
  * **Tier 5-a: IF 임베딩 캐시 X (캐시에 해당 함수의 임베딩이 없는 경우)**: Tier 6의 "함수 임베딩" 단계로 바로 이동하여 새로운 임베딩을 생성  
  * **Tier 5-b: IF 임베딩 캐시 O (캐시에 해당 함수의 임베딩이 있는 경우)**: 캐시된 임베딩을 사용하되, 추가적인 조건에 따라 분기  
    * **Diff O, AST 기반 유사도 90% 미만**: 해당 함수에 Diff가 존재하고, (아마도 캐시된 버전과의) AST 기반 유사도가 90% 미만이라면, 변경의 폭이 크다고 판단하여 Tier 6의 "함수 임베딩" 단계로 이동하여 임베딩을 새로 생성하거나 업데이트  
    * **Diff O, AST 기반 유사도 90% 이상**: Diff는 있지만 AST 유사도가 90% 이상으로 높다면, 변경이 미미하다고 보고 Tier 6의 "임베딩 캐시 재사용"으로 이동하여 기존 임베딩을 활용  
    * **Diff X**: 해당 함수에 Diff가 없다면, 변경이 없으므로 Tier 6의 "임베딩 캐시 재사용"

**Tier 6: 임베딩 벡터 준비 (생성 또는 재사용)**

* 최종적으로 분석에 사용될 함수의 임베딩 벡터를 준비  
  * **함수 임베딩 (신규 생성 또는 업데이트)**:  
    * Tier 5-a 또는 Tier 5-b의 특정 조건(Diff O, AST 유사도 90% 미만)을   
      만족하는 경우 실행  
    * A-2, C-2 스코핑 경로에서는 BERT 임베딩을,  
      B-2 스코핑 경로에서는 Code2Vec 임베딩을 사용  
    * 만약 여러 스코핑 경로의 결과가 혼합되어 있다면,   
      **BERT 임베딩으로 통일**하여 고품질 임베딩을 우선시하며 이후 추적을 용이하게 함  
  * **임베딩 캐시 재사용**:  
    * Tier 5-b의 특정 조건(Diff O, AST 유사도 90% 이상 또는 Diff X)을   
      만족하는 경우 실행  
    * 만약 다양한 종류의 캐시된 임베딩이 혼재한다면 (예: 이전 버전은 Code2Vec, 현재는 BERT 우선), 일관성을 위해 **BERT로 다시 임베딩**하거나, 가장 최신/고품질의 임베딩을 선택하는 로직

**Tier 7: 최종 컨텍스트 함수 필터링 (유사도 기반)**

* 준비된 임베딩 벡터를 사용하여 Main module과 Sub module 간의 최종적인 유사도를 계산, 기술 설명서 및 커밋 메시지 생성에 사용될 핵심 컨텍스트 함수들을 필터링  
  * **A-2, B-2 스코핑 경로**: 이전 단계의 Top 7(또는 10)개의 Sub module을 대상으로,  
    Main module과의 임베딩 벡터 유사도 순으로 상위 3개를 최종 선택  
  * **C-2 스코핑 경로**: 이전 단계의 Top 3(또는 5)개의 Sub module 그룹에 대해, 전체에서 Main module과 가장 유사한 총 3개의 핵심 Sub module을 "각 함수별 3개씩 Scoping" (중복 불가), 여러 Main module을 동시에 처리하여  **"가장 관련성 높은 Sub module 3개를 최종 선정한다"**

**Tier 8: 기술 설명서 생성용 프롬프트 작성**

* LLM에게 전달하여 "함수별 기술 설명서"를 생성하기 위한 프롬프트를 구성  
  * **입력 요소**:  
    * 대상 저장소의 Readme 파일 요약 (존재하는 경우)  
    * Tier 7에서 최종 필터링된 유사도 상위 3개 Sub module이 포함된 파일들의 경로  
    * Main module 전문 \+ 최종 필터링된 3개 Sub module의 전문 (총 4개 모듈의 전체 코드)  
    * "Main module의 저장소 내에서의 역할을 설명해달라"는 내용의 고정 프롬프트

**Tier 9: LLM 호출 (기술 설명서 생성)**

* Tier 8에서 작성된 프롬프트를 LLM에게 전달하여, 각 Main module(및 컨텍스트 Sub module)에 대한 상세한 **기술 설명서를 생성**

**Tier 10: 커밋 메시지 생성용 프롬프트 작성**

* Tier 9에서 생성된 기술 설명서를 기반으로,   
  최종 커밋 메시지를 생성하기 위한 프롬프트를 다시 구성  
  * **입력 요소**:  
    * 함수별 기술 설명서 (최대 5개 함수의 설명)  
    * 각 함수별로 (임베딩) 유사도가 높은 다른 파일들의 경로   
      (각 함수당 유사도 Top 1 파일, 최대 5개 함수의 파일 목록)  
    * 해당 파일들의 경로  
    * Readme 파일 요약 (존재하는 경우)  
    * 파일 Diff 정보 (수정 전 코드와 수정 후 코드 두 가지만 간결하게 제공)

**Tier 11: LLM 호출 (커밋 메시지 생성)**

* Tier 10에서 작성된 프롬프트를 LLM에게 전달하여, 분석된 변경사항 전체에 대한   
  **파일별 또는 통합된 커밋 메시지를 생성**